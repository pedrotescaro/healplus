
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to get user role
    function getRole(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data.role;
    }
    
    // Profiles can be read by any authenticated user, but only written/deleted by the owner.
    match /users/{userId} {
      allow read: if request.auth != null;
      allow write, delete: if request.auth.uid == userId;

      // Professionals have full access to their own subcollections.
      // Patients can read reports from a professional's subcollection if the report belongs to them.
      match /reports/{reportId} {
        allow write: if getRole(request.auth.uid) == 'professional' && request.auth.uid == userId;
        allow read: if (getRole(request.auth.uid) == 'professional' && request.auth.uid == userId) || 
                      (getRole(request.auth.uid) == 'patient' && resource.data.patientId == request.auth.uid);
      }
      
      // Professionals have full access to their other subcollections
      match /{subcollection}/{docId} {
         allow read, write: if subcollection != 'reports' && getRole(request.auth.uid) == 'professional' && request.auth.uid == userId;
      }
    }

    // This rule allows patients to query the 'reports' collection group.
    // It ensures they can only get reports where their UID is the patientId.
    match /{path=**}/reports/{reportId} {
      allow list: if getRole(request.auth.uid) == 'patient' && request.query.where.get("patientId")[2][0] == request.auth.uid;
    }

    // Chats can only be accessed by the participants
    match /chats/{chatId}/{message=**} {
      // This rule is simplified as chat participant logic is managed in the backend.
      // A more secure rule would check a 'participants' array in the chat document.
      allow read, write: if request.auth != null;
    }
  }
}
